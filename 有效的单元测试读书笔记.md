### 《有效的单元测试》笔记

#### 第一章 优秀测试的承诺

> - 编写单元测试的价值 
> - 测试如何提高程序员的生产力
> - 将测试用作设计工具

1. 100%测试覆盖率不是目标

   100%听起来肯定比95%要好，但是区别在于那些测试的价值对你可能是微不足道的。这要看哪种代码没有被测试覆盖，以及你的测试能否暴露程序的错误。100%的覆盖率并不能够确保没有缺陷——它只是保证你所有的代码都执行了，无论程序的行为是否满足要求。与其追求代码覆盖率，不如将重点关注在确保写出有意义的测试。

2. 测试越多，额外测试的价值越少。第一个测试最有可能是针对代码最重要的区域，因此带来高价值与高风险。当我们为几乎所有事情编写测试后，那些仍然没有测试覆盖的地方很可能是最不重要和最不可能破坏的。

    ![测试的价值](https://github.com/zkRou/note/blob/master/%E6%B5%8B%E8%AF%95%E6%9B%BF%E8%BA%AB.jpg)

3. 将测试作为安全网只是等式的一部分，而另一部分——或许是更大部分——其好处是我们将测试表达为代码的思考过程。


#### 第二章 寻求优秀

> - 测试怎样才算“优秀”
> - 测试相关的行为
> - 可靠测试的重要性

- 可读的代码才是可维护的代码
- 结构有助于理解事物

	结构是有用的，缺乏结构是有害的。

    代码结构是否有助于你快速而可靠地找到高层概念的代码实现所在。

- 在测试类中不要依赖于测试的顺序

    一般来说，不让测试相互依赖是指你不该让一个类中的测试依赖另一个类中测试的执行或结果。

- 测试替身：是stub(桩)、fake(伪造对象)、mock(模拟对象)的总称。他们本质上是为了测试目的、用于替换真实协作者的对象。

    好处：

        - 通过简化要执行的代码来加速执行测试
        - 模拟难以出现的异常情况
        - 观察那些对测试代码不可见的状态和交互

- 编写自动化测试的三个工具：

    1. 用于编写测试的测试框架
    2. 改善测试及可测试性的测试替身
    3. 用来运行测试的自动化构建(不论你的构建过程是怎样的，构建脚本中用到哪种工具或技术，都没理由不将自动化测试集成到构建中)

#### 第四章 测试替身

> - 我们能用测试替身做些什么
> - 那些测试替身可供选择
> - 使用测试替身的指南

- 为了时不时地验证一段代码的行为符合你的期望，最好的选择是替换其周围的代码，使你获得对环境的完整控制，从而在其中测试你的代码。

    ![测试替身](https://github.com/zkRou/note/blob/master/%E6%B5%8B%E8%AF%95%E6%9B%BF%E8%BA%AB.jpg)

    测试替身帮助你隔离被测代码，这样你就能测试其行为的各个方面。本例中，我们用测试替身替换掉了三个协作者中的两个，将测试范围确定为被测代码本身的行为和协作，外加一个特定的协作者。

    这是引入测试替身的最根本原因 - 将被测代码与周围隔离开。



#### 附录A JUnit入门

1. JUnit两个基本元素：JUnit测试代码的结构和生命周期

2. JUnit忽略：

    - 非public方法

    - 方法有参数

    - 方法返回非void

    - 方法声明为stataic

    - 方法没有`@Test`注解

3. 测试类可以有任意多的`@Before`和`@After`,JUnit会确保调用一个，尽管它不保证调用的顺序。 

4. JUnit断言： 用于判断两个对象是否相等，对象引用是否为null，两个对象引用是否指向同一个对象，条件是ture还是false等。

    - 抛出断言异常

        - 使用`@Test`注解的`expect`属性来声明我们期望在测试方法执行时抛出一个IllegalArgumentException。如果没有抛出该异常（或者抛出了其他异常），测试就会失败。

        - 如果要更具体地了解抛出的是哪种异常（例如，除了抛出的异常要符合某个类型之外，还想检查其message中携带的特殊信息），则可以使用try-catch，然后自行断言

        ```java
        @Test
        public void ensureThatInvalidPhoneNumberYieldsProperException(){
            String invalidPhoneNumber = "+n0t-a-valid-ph03n-Numbe3r";
            FaxMachine fax = new FaxMachine();
            try{
                fax.connect(invalidPhoneNumber);
                fail("should've raised an exception by now");//如果没有异常抛出，就令测试失败
            } catch(IllegalargumentException expected){ //捕获期望的异常
                assertThat(expected.getMessage(), containsString(invalidPhoneNumber)); //进一步对异常进行断言
            }
        }
        ```

    - 扩展断言 - AssertThat()和Hamcrest匹配器

        基本语法：assertThat(someObject, [matchesThisCondition])

        第一个参数：断言上下文的对象或值

        第二个参数：`Hamcrest`匹配器，JUnit会将实际的断言工作委托给它

        `Hamcrest`是一个开源API，提供了一组标准的匹配器实现。如果内置的断言或Hamcrest匹配器都不满足需求，则可以通过实现Hamcrest的`Matcher`接口来创建自己的匹配器。

        ```java
        public class ExampleTest{
            ...
            @Test
            public void providesPhoneNumberInInternationalFormat(){
                String phoneNumber = widgeUnderTest.getPhoneNumber();
                assertThat(phoneNumber, is(internationalPhoneNumber));
            }

            public Matcher<String> internationalNumber(){
                return new BaseMatcher<String>(){ //扩展BaseMatcher
                    @Override
                    public boolean matches(Object candidate){
                        if(!(candidate instanceof String)){ //只接受字符串
                            return false;
                        }
                        return ((String)candidate).matches("^\\+(?:[0-1]?){6,14}[0-9]$");
                    }
                    
                    @Override
                    public void describeTo(Description desc){
                        desc.appendText("ITU-T E.123 compliant international phone number");
                    }
                }
            }
        }
        ```
        当测试调用`assertThat`时，JUnit使用辅助方法`BaseMatcher`来执行断言。

        自定义的匹配器实现包含两个方法。
        - `matches()`：指出给定的候选对象是否通过了断言。
        - `describeTo()`：负责给匹配器要寻找的内容提供有意义的描述。
