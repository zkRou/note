---
title: 使用Java计算btc地址
author: Kairou Zeng
date: 2018/12/04
tags: [区块链]
---

## 为什么写
需要开发一个新的数字身份服务项目，由于旧的数字身份服务中的账户地址是通过同事开发的权限链码获得，新的数字身份系统欲抛弃链码部分，因为没有找到有供Java使用的现成的生成该地址的库，因此需要使用Java来实现获取账户地址。

*说明：*本文所描述的`账户地址`，即公钥经过多次哈希散列及处理的地址，即以太坊中用来识别账户的地址，原链码即参考比特币地址算法实现。

## 为什么需要`这个地址`

地址是为了人们交换方便而弄出来的一个方案，因为公钥太长了。

## 基础概念

### 哈希/散列函数

**典型算法：** SHA，MD5

**算法思想：** 

- 如果两个散列值是不相同的，那么这两个散列值的原始输入也是不相同的，即使Hash(x) != Hash(y)
- 用于信息压缩，并发现信息是否发生变化
- 计算速度快，特定算法其结果长度统一

### 对称加密算法

**典型算法：** DES，AES

**算法思想：** 

- 加解密共用一个密钥
- 加/解密速度快，但密钥分发及管理困难，密钥交换的安全性不能保障，不够安全(在数据传送前，发送方和接收方必须商定好密钥，然后双方都必须要保存好密钥，如果一方的密钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一密钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。)
- 区块链主要使用ECC椭圆曲线算法

### 非对称加密算法

**典型算法：** RSA，ECC

**算法思想：** 

- 加解密时，通讯一方有一对密钥（公钥和私钥）
- 公钥可以公开，分发给任何人
- 私钥不可以公开，严格持有
- 公钥加密，只能用私钥解密，反之亦然
- 加/解密速度较慢，但无密钥分发问题

### 数字签名

**目的：** 

- 检测数据未经授权的修改，签名者的身份识别和抗抵赖。
- 数字证书体系也是以此为核心:
	如果A有数字身份，则:
		1. A有自己的一对公钥和私钥；
		2. 数字身份的发证机关，证明了这个公钥对应的持有人是张三）。

### 数字证书 

> 是由认证中心发放并经认证中心数字签名的，可以用来证明数字证书持有者的真实身份

- 数字证书采用公钥体制:
	- 数字证书是”公钥+证书名称信息+签发机构对证书的数字签名”、匹配的私钥
	- 数字证书遵从X.509国际标准

### 过程

如果A给B发送一个加密的有数字签名的文件，会怎么样呢？
首先A有自己的公钥和私钥：A_public_key, A_private_key
B也有自己的公钥和私钥：B_public_key, B_private_key
- A和B互换公钥
- A将文件用hash算法生成摘要，用A_private_key对摘要加密，得到的就叫数字签名
- A用B_public_key对文件加密
- 将加密的文件和数字签名一起发给B
 ------B收到内容后------
- 用B_private_key解密文件，得到明文
- 用A_public_key解密数字签名，得到内容摘要
	- 解密数字签名时，需要事先知道发送方A的A_public_key，因此需要确定自己得到的A_public_key确实是发送方A的（例如：C知道B的公钥，然后偷偷把B手里A的公钥A_public_key换成自己的公钥C_public_key，那么以后C给B发送的东西，B还一直以为是A发送的。因为B不知道自己手里公钥就是A的），就需要使用数字证书。
	- 证书无法伪造，因为数字证书里里有CA的数字签名，签名是由证书内容的哈希摘要用CA的私钥加密的。用CA的公钥验证签名的合法性就可以验证证书的真假。
	- A找证书中心（CA）申请自己的证书，CA把A的公钥和一些信息作为证书内容写入，然后用CA自己的私钥生成数字签名一并写入证书。A给B发数据时把用B的公钥加密的数据、A的数字签名、A的数字证书一起发过去。B的电脑安装有根证书（操作系统带的，知道CA的公钥），用CA的公钥验证A的数字证书里面签名的合法性，合法后从证书内容里读出A的公钥。再用A的公钥解密A的数字签名验证数据完成性。最后用B的私钥解密数据。
 - 将明文的文件内容用同样hash算法得到摘要，与第六步的摘要对比。相同则证明内容和来源都正确。

=> 加密：公钥加密，私钥解密；认证：私钥加密，公钥解密

*参考：*

[数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)

## 原链码获取地址实现

*特别说明：* 由于涉及到公司内部代码，以下仅仅简化版，无法运行，仅供参考。

```go 
import (
	"bytes"
	"crypto/ecdsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"math/big"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
)

func getAddress(stub shim.ChaincodeStubInterface) ([]byte， error) {

	//Get cert
	certText := creatorByte[certStart:]
	bl， _ := pem.Decode(certText)
	
    //Get publicKey from cert
	cert， err := x509.ParseCertificate(bl.Bytes)

    //以下为获取地址重点
	if pub， ok := cert.PublicKey.(*ecdsa.PublicKey); ok {
		pubKey := append(pub.X.Bytes()， pub.Y.Bytes()...)
		publicSHA256 := sha256.Sum256(pubKey)
		address := Base58Encode(publicSHA256[:])

		log.Debugf("[getAddress] %s\n"， address)
		return address， nil
	}

	log.Warning("[getAddress]"， "Only support ECDSA")
	return nil， errors.New("Only support ECDSA")
}

// Base58Encode encodes a byte array to Base58
func Base58Encode(input []byte) []byte {
	//Base58 encode 
}

```